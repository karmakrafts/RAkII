/*
 * Copyright 2025 Karma Krafts & associates
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.karmakrafts.rakii.compiler

import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrField
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.createBlockBody
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrGetFieldImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrGetValueImpl
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.SYNTHETIC_OFFSET
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.ir.util.parentClassOrNull
import org.jetbrains.kotlin.ir.util.properties
import org.jetbrains.kotlin.ir.visitors.IrVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid

internal class DropGenerationVisitor(
    private val pluginContext: IrPluginContext
) : IrVisitorVoid() {
    private val messageCollector: MessageCollector = pluginContext.messageCollector

    override fun visitElement(element: IrElement) {
        element.acceptChildrenVoid(this)
    }

    @OptIn(UnsafeDuringIrConstructionAPI::class)
    private fun findDroppableProperties(declaration: IrClass): List<IrProperty> {
        // Find all delegate properties with a matching backing field type
        return declaration.properties.filter { it.backingField?.type?.isDropDelegate() == true }.onEach {
            messageCollector.report(
                CompilerMessageSeverity.LOGGING, "Found droppable property ${it.name} in ${declaration.kotlinFqName}"
            )
        }.toList()
    }

    private fun createDropCall(field: IrField, declaration: IrSimpleFunction): IrCall {
        return IrCallImpl( // @formatter:off
            startOffset = SYNTHETIC_OFFSET,
            endOffset = SYNTHETIC_OFFSET,
            symbol = pluginContext.referenceFunctions(RAkIINames.DropDelegate.drop).first(),
            type = pluginContext.irBuiltIns.unitType
        ).apply {
            // We are calling drop on the instance stored in the backing field
            dispatchReceiver = IrGetFieldImpl(
                startOffset = SYNTHETIC_OFFSET,
                endOffset = SYNTHETIC_OFFSET,
                symbol = field.symbol,
                type = field.type
            ).apply {
                // We are retrieving the backing field value from the this-reference of the parent class
                val thisParam = declaration.dispatchReceiverParameter!!
                receiver = IrGetValueImpl(
                    startOffset = SYNTHETIC_OFFSET,
                    endOffset = SYNTHETIC_OFFSET,
                    type = thisParam.type,
                    symbol = thisParam.symbol
                )
            }
        } // @formatter:on
    }

    override fun visitSimpleFunction(declaration: IrSimpleFunction) {
        super.visitSimpleFunction(declaration)
        val origin = declaration.origin
        // If the function wasn't generated by our compiler plugin, return early
        if (origin !is IrDeclarationOrigin.GeneratedByPlugin || origin.pluginKey != DropGenerationExtension.Key) return
        // Generate the body for our drop function
        val clazz = declaration.parentClassOrNull ?: return
        // Skip if class is marked with @SkipDropTransforms
        if (clazz.shouldSkipDropTransforms()) return
        val properties = findDroppableProperties(clazz)
        messageCollector.report(
            CompilerMessageSeverity.LOGGING, "Processing drop function for ${declaration.kotlinFqName.asString()}"
        )
        declaration.body = pluginContext.irFactory.createBlockBody(SYNTHETIC_OFFSET, SYNTHETIC_OFFSET) {
            statements += properties.mapNotNull { it.backingField }
                .reversed() // Properties are always dropped in reverse order to how they're declared
                .map { createDropCall(it, declaration) }
        }
    }
}
